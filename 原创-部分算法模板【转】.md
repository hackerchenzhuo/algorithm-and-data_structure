# 原创：部分算法模板【转】

> 
<p>作者：键盘里的青春 <br/>
来源：CSDN <br/>
原文：https://blog.csdn.net/qq_34374664/article/details/80412575 </p>


目录

 

最短路spfa、dij、floyd + 记录路径

floyd：

spfa 和 dij

次短路

其他例题：

博弈

SG函数

尼姆博弈

威佐夫博弈

巴什博弈

 

Tarjan算法

缩点裸题

强联通缩点的应用

最小生成树

prime

Krusal

匈牙利裸题

区间更新区间查询

DP

求最大子矩阵

最大子段和

最长公共子序列

最长公共子串

LIS

LICS

矩阵取数（多线程DP）

背包模板

并查集

字符串

马拉车

kmp

对主串做next数组

对子串做next数组

扩展KMP

字典树

矩阵快速幂

错排公式

康拓展开式

逆元

线性筛

LCA

最短路spfa、dij、floyd + 记录路径<br/>
floyd：<br/>
思路：用一个二维数组path[][]来记录。这里有两种方法，1 用path[ i ][ j ]记录 j 的前驱顶点 ；2 用path[ i ][ j ]记录 i 的后面的点。

提醒：需要注意的是path的初始化

#include &lt;cstdio&gt;<br/>
#include &lt;cstring&gt;<br/>
#include &lt;stack&gt;<br/>
#include &lt;algorithm&gt;<br/>
#define INF 1000000+10<br/>
using namespace std;<br/>
int Map[500][500]; <br/>
int pre[500][500];//记录当前顶点的 前一个顶点 <br/>
int n, m;<br/>
void init()<br/>
{<br/>
    for(int i = 1; i &lt;= n; i++)<br/>
    {<br/>
        for(int j = 1; j &lt;= n; j++)<br/>
        {<br/>
            Map[i][j] = i==j ? 0 : INF;<br/>
            pre[i][j] = j;//初始化 <br/>
        }<br/>
    }<br/>
} <br/>
void getMap()<br/>
{<br/>
    int a, b, c;<br/>
    while(m--)<br/>
    {<br/>
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);<br/>
        if(Map[a][b] &gt; c)<br/>
        Map[a][b] = c;<br/>
    } <br/>
}<br/>
void floyd()<br/>
{<br/>
    int i, j, k;<br/>
    for(k = 1; k &lt;= n; k++)<br/>
    {<br/>
        for(i = 1; i &lt;= n; i++)<br/>
        {<br/>
            for(j = 1; j &lt;= n; j++)<br/>
            {<br/>
                if(Map[i][j] &gt; Map[i][k] + Map[k][j])<br/>
                {<br/>
                    Map[i][j] = Map[i][k] + Map[k][j];<br/>
                    pre[i][j] = pre[i][k];//记录 <br/>
                }<br/>
            } <br/>
        } <br/>
    } <br/>
}<br/>
int main()<br/>
{<br/>
    int s, e;<br/>
    while(scanf("%d %d", &amp;n, &amp;m), n||m)<br/>
    {<br/>
        init();<br/>
        getMap();<br/>
        floyd();<br/>
        while(scanf("%d%d", &amp;s, &amp;e), s!=-1||e!=-1)<br/>
        {<br/>
            if(s == e)<br/>
            {<br/>
                printf("从%d到%d的最优路线 : %d\n", s, e, s);<br/>
                printf("最小花费 : %d\n", 0);<br/>
                continue;<br/>
            }<br/>
            printf("从%d到%d的最优路线 : %d", s, e, s);<br/>
            int now = pre[s][e];<br/>
            while(1)<br/>
            {<br/>
                printf("--&gt;%d", now);<br/>
                if(now == e)<br/>
                break;<br/>
                now = pre[now][e];<br/>
            }<br/>
            printf("\n");<br/>
            printf("最小花费 : %d\n", Map[s][e]);<br/>
        }<br/>
    }<br/>
    return 0;<br/>
}<br/>
    for(int i = 1; i &lt;= n; i++)<br/>
    {<br/>
        for(int j = 1; j &lt;= n; j++)<br/>
        {<br/>
            Map[i][j] = i==j ? 0 : INF;<br/>
            pre[i][j] = j;//初始化 <br/>
        }<br/>
    }<br/>
} <br/>
void getMap()<br/>
{<br/>
    int a, b, c;<br/>
    while(m--)<br/>
    {<br/>
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);<br/>
        if(Map[a][b] &gt; c)<br/>
        Map[a][b] = c;<br/>
    } <br/>
}<br/>
void floyd()<br/>
{<br/>
    int i, j, k;<br/>
    for(k = 1; k &lt;= n; k++)<br/>
    {<br/>
        for(i = 1; i &lt;= n; i++)<br/>
        {<br/>
            for(j = 1; j &lt;= n; j++)<br/>
            {<br/>
                if(Map[i][j] &gt; Map[i][k] + Map[k][j])<br/>
                {<br/>
                    Map[i][j] = Map[i][k] + Map[k][j];<br/>
                    pre[i][j] = pre[i][k];//记录 <br/>
                }<br/>
            } <br/>
        } <br/>
    } <br/>
}<br/>
int main()<br/>
{<br/>
    int s, e;<br/>
    while(scanf("%d %d", &amp;n, &amp;m), n||m)<br/>
    {<br/>
        init();<br/>
        getMap();<br/>
        floyd();<br/>
        while(scanf("%d%d", &amp;s, &amp;e), s!=-1||e!=-1)<br/>
        {<br/>
            if(s == e)<br/>
            {<br/>
                printf("从%d到%d的最优路线 : %d\n", s, e, s);<br/>
                printf("最小花费 : %d\n", 0);<br/>
                continue;<br/>
            }<br/>
            printf("从%d到%d的最优路线 : %d", s, e, s);<br/>
            int now = pre[s][e];<br/>
            while(1)<br/>
            {<br/>
                printf("--&gt;%d", now);<br/>
                if(now == e)<br/>
                break;<br/>
                now = pre[now][e];<br/>
            }<br/>
            printf("\n");<br/>
            printf("最小花费 : %d\n", Map[s][e]);<br/>
        }<br/>
    }<br/>
    return 0;<br/>
}<br/>
spfa 和 dij<br/>
HDU 1224

题意：给你n个城市，每个城市都有一个风景值,再给你m条路，每条路连接两个城市，只能从序号小的到序号大的，问你从1号到n+1号能经过的风景值得和最大为多少，并且输出路径。

import java.util.Arrays;<br/>
import java.util.LinkedList;<br/>
import java.util.PriorityQueue;<br/>
import java.util.Queue;<br/>
import java.util.Scanner;<br/>
import java.util.Vector;<br/>
 <br/>
class Main<br/>
{<br/>
    static final int maxn = 1000;<br/>
    static final int INF = 0x3f3f3f3f; <br/>
    static int[] dis = new int[maxn];<br/>
    static int[] book = new int[maxn];<br/>
    static int[] pre = new int[maxn];<br/>
    static int[] cost = new int[maxn];<br/>
    static int[] res = new int[maxn];<br/>
    static class node implements Comparable&lt;node&gt;<br/>
    {<br/>
        int to, w;<br/>
        node(int tt, int ww)<br/>
        {<br/>
            this.to = tt;<br/>
            this.w = ww;<br/>
        }<br/>
        @Override<br/>
        public int compareTo(node o) <br/>
        {<br/>
            // TODO Auto-generated method stub<br/>
            return this.w - o.w;<br/>
        }<br/>
    }<br/>
    static Vector&lt;node&gt;[] v = new Vector[maxn];<br/>
    static void spfa()<br/>
    {<br/>
        Arrays.fill(book, 0);<br/>
        Arrays.fill(pre, -1);<br/>
        Arrays.fill(dis, 0);<br/>
        Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();<br/>
        q.add(1);<br/>
        dis[1] = 0;<br/>
        while(!q.isEmpty())<br/>
        {<br/>
            int u = q.poll();<br/>
            book[u] = 0;<br/>
            for(int i = 0; i &lt; v[u].size(); i++)<br/>
            {<br/>
                int to = v[u].get(i).to;<br/>
                if(dis[to] &lt; dis[u] + cost[to])<br/>
                {<br/>
                    dis[to] = dis[u] + cost[to];<br/>
                    pre[to] = u;<br/>
                    if(book[to] == 0)<br/>
                    {<br/>
                        book[to] = 1;<br/>
                        q.add(to);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    static void dij()<br/>
    {<br/>
        Arrays.fill(dis, 0);<br/>
        Arrays.fill(pre, -1);<br/>
        Queue&lt;node&gt; pq = new PriorityQueue&lt;node&gt;();<br/>
        pq.add(new node(1, 0));<br/>
        while(!pq.isEmpty())<br/>
        {<br/>
            int u = pq.poll().to;<br/>
            for(int i = 0; i &lt; v[u].size(); i++)<br/>
            {<br/>
                int to = v[u].get(i).to;<br/>
                if(dis[to] &lt; dis[u] + cost[to])<br/>
                {<br/>
                    pre[to] = u;<br/>
                    dis[to] = dis[u] + cost[to];<br/>
                    pq.add(new node(to, dis[to]));<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    public static void main(String[] args) <br/>
    {<br/>
        Scanner sc = new Scanner(System.in);<br/>
        for(int i = 0; i &lt; maxn; i++) <br/>
            v[i] = new Vector&lt;node&gt;();<br/>
        int _, n, m, ca = 1;<br/>
        _ = sc.nextInt();<br/>
        while(_-- &gt; 0)<br/>
        {<br/>
            for(int i = 0; i &lt; maxn; i++)<br/>
            {<br/>
                v[i].clear();<br/>
                cost[i] = 0;<br/>
                <br/>
            }<br/>
            n = sc.nextInt();<br/>
            for(int i = 1; i &lt;= n; i++)<br/>
                cost[i] = sc.nextInt();<br/>
            m = sc.nextInt();<br/>
            for(int i = 1; i &lt;= m; i++)<br/>
            {<br/>
                int u = sc.nextInt();<br/>
                int to = sc.nextInt();<br/>
                if(u &gt; to) <br/>
                {<br/>
                    int tmp = u;<br/>
                    u = to;<br/>
                    to = tmp;<br/>
                }<br/>
                v[u].add(new node(to, 0));<br/>
            }<br/>
            //spfa();<br/>
            dij();<br/>
            System.out.println("CASE " + (ca++) + "#");  <br/>
            System.out.println("points : " + dis[n + 1]);  <br/>
            System.out.print("circuit : ");  <br/>
            int cnt = 0;<br/>
            int p = n + 1;<br/>
            while(p != -1)<br/>
            {<br/>
                res[cnt++] = p;<br/>
                p = pre[p];<br/>
            }<br/>
            for(int i = cnt-1; i &gt; 0; i--)<br/>
                System.out.print(res[i] + "-&gt;");<br/>
            System.out.println(1);<br/>
            if(_ != 0)<br/>
                System.out.println();<br/>
        }<br/>
    }<br/>
}<br/>
次短路<br/>
 

题意：给你一个有向图，问你他的次短路长度（与最短路至少有一条边不同即可）

思路：如果最短路有多条，那答案就是最短路，否则就是次短路

次短路思路： <br/>
        把求最短路时更新最短路的那部分改一下。 <br/>
        dis1，dis2数组分别记录到该点的最短路和次短路 <br/>
        分三种情况： <br/>
            1.若该点最短路+下一条边比到下个点的最短路短，则更新下个点的最短路，同时更新次短路为原最短路 <br/>
            2.若该点次短路+下一条边比到下个点的次短路短，则更新下个点的次短路 <br/>
            3.若该点最短路+下一条边比到下个点的最短路长同时比下个点的次短路短，则更新下个点的次短路 

#include&lt;iostream&gt;<br/>
#include&lt;cstdio&gt;<br/>
#include&lt;queue&gt;<br/>
#include&lt;cstring&gt;<br/>
#include&lt;algorithm&gt;<br/>
using namespace std;<br/>
typedef long long ll;<br/>
const int maxn = 2e5+5;<br/>
const ll INF = 0x3f3f3f3f3f3f3f3f;<br/>
int n, m, k, head[maxn];<br/>
ll cnt[maxn];<br/>
ll dis1[maxn], dis2[maxn], dis[maxn];<br/>
bool book[maxn];<br/>
 <br/>
struct node<br/>
{<br/>
    int v, w, next;<br/>
}edge[maxn];<br/>
 <br/>
void addEdge(int u, int v, int w)<br/>
{<br/>
    edge[k].v = v;<br/>
    edge[k].w = w;<br/>
    edge[k].next = head[u];<br/>
    head[u] = k++;<br/>
}<br/>
 <br/>
void spfa(int u)<br/>
{<br/>
    for(int i = 1; i &lt;= n; i++) dis1[i] = INF;<br/>
    for(int i = 1; i &lt;= n; i++) dis2[i] = INF;<br/>
    memset(book, 0, sizeof(book));<br/>
    queue&lt;int&gt; q;<br/>
    q.push(u);<br/>
    dis1[u] = 0;<br/>
    book[u] = 1;<br/>
    while(!q.empty())<br/>
    {<br/>
        u = q.front(); q.pop();<br/>
        book[u] = 0;<br/>
        for(int i = head[u]; i != -1; i = edge[i].next)<br/>
        {<br/>
            int v = edge[i].v;<br/>
            int w = edge[i].w;<br/>
            if(dis1[v] &gt; dis1[u]+w)<br/>
            {<br/>
                dis2[v] = dis1[v];<br/>
                dis1[v] = dis1[u]+w;<br/>
                if(!book[v]) book[v] = 1, q.push(v);<br/>
            }<br/>
            if(dis2[v] &gt; dis2[u]+w)<br/>
            {<br/>
                dis2[v] = dis2[u]+w;<br/>
                if(!book[v]) book[v] = 1, q.push(v);<br/>
            }<br/>
            if(dis1[v] &lt; dis1[u]+w &amp;&amp; dis2[v] &gt; dis1[u]+w)<br/>
            {<br/>
                dis2[v] = dis1[u]+w;<br/>
                if(!book[v]) book[v] = 1, q.push(v);<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
 <br/>
void spfa2(int u)<br/>
{<br/>
    for(int i = 1; i &lt;= n; i++) dis[i] = INF;<br/>
    memset(book, 0, sizeof(book));<br/>
    queue&lt;int&gt; q;<br/>
    q.push(u);<br/>
    book[u] = cnt[u] = 1;<br/>
    dis[u] = 0;<br/>
    while(!q.empty())<br/>
    {<br/>
        u = q.front(); q.pop();<br/>
        book[u] = 0;<br/>
        for(int i = head[u]; i != -1; i = edge[i].next)<br/>
        {<br/>
            int v = edge[i].v;<br/>
            int w = edge[i].w;<br/>
            if(dis[u]+w &lt; dis[v])<br/>
            {<br/>
                dis[v] = dis[u]+w;<br/>
                if(!book[v]) book[v] = 1, q.push(v);<br/>
                cnt[v] = cnt[u];<br/>
            }<br/>
            else if(dis[u]+w == dis[v])<br/>
            {<br/>
                cnt[v] += cnt[u];<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
 <br/>
int main(void)<br/>
{<br/>
    int t;<br/>
    cin &gt;&gt; t;<br/>
    while(t--)<br/>
    {<br/>
        k = 0;<br/>
        memset(cnt, 0, sizeof(cnt));<br/>
        memset(head, -1, sizeof(head));<br/>
        scanf("%d%d", &amp;n, &amp;m);<br/>
        for(int i = 1; i &lt;= m; i++)<br/>
        {<br/>
            int u, v, w;<br/>
            scanf("%d%d%d", &amp;u, &amp;v, &amp;w);<br/>
            addEdge(u, v, w);<br/>
            addEdge(v, u, w);<br/>
        }<br/>
        spfa(1);<br/>
        spfa2(1);<br/>
        if(cnt[n] &gt; 1) printf("%lld\n", dis1[n]);<br/>
        else printf("%lld\n", dis2[n]);<br/>
    }<br/>
    return 0;<br/>
}<br/>
 

其他例题：<br/>
 

路径最大权值最小

博弈<br/>
SG函数<br/>
sg 即Graph Game，把博弈游戏抽象成有向无环图<br/>
(1) 有向无环图<br/>
(2) 玩家1先移动，起点是x0<br/>
(3) 两个玩家轮流移动<br/>
(4) 对于顶点x, 玩家能够移动到的顶点集记为F(x).<br/>
(5) 不能移动的玩家会输掉游戏<br/>
首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、 mex{2,3,5}=0、mex{}=0。<br/>
定义: 一个图的Sprague-Grundy函数(X,F)是定义在X上的非负函数g(x)，并且满足：

       g(x) = mex{g(y) : y∈F(x)}

假设游戏 Gi的SG函数是gi, i=1,…,n, 则G = G1 + … + Gn 的 SG函数是g(x1,…,xn) = g1(x1)^…^gn(xn).

g(x) &gt; 0 必胜， g(x) == 0 必输

例题：

  这是一个二人游戏，一共有3堆石子，数量分别是m, n, p个，两人轮流走， 每走一步可以选择任意一堆石子，然后取走f个， f只能是菲波那契数列中的元素（即每次只能取1，2，3，5，8…等数量）， 最先取光所有石子的人为胜者，假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢,  如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。

#include &lt;iostream&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e3 + 5;  <br/>
int f[maxn], sg[maxn], book[maxn];  <br/>
void init()  <br/>
{  <br/>
    f[1] = 1;  <br/>
    f[2] = 2;  <br/>
    for(int i = 3; i &lt;= maxn; i++)  <br/>
    f[i] = f[i-1] + f[i-2];  <br/>
}  <br/>
void get_sg()  <br/>
{  <br/>
    for(int i = 1; i &lt;= maxn; i++)  //从1枚举所有状态<br/>
    {  <br/>
        memset(book, 0, sizeof(book));  //计算mex的<br/>
        for(int j = 1; f[j] &lt;= i; j++)   //枚举这个状态所有可能到达的状态<br/>
        {  <br/>
            book[sg[i-f[j]]] = 1;   // 计算能到达的状态的sg是否出现过<br/>
        }  <br/>
        for(int j = 0; book[j]; j++)   //计算mex<br/>
            sg[i] = j + 1;  <br/>
    }  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int m, n, p;  <br/>
    init();  <br/>
    get_sg();  <br/>
    while(cin &gt;&gt; m &gt;&gt; n &gt;&gt; p, m+n+p)  <br/>
    {  <br/>
        puts(sg[n]^sg[m]^sg[p] ? "Fibo" : "Nacci");  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
尼姆博弈<br/>
尼姆博奕 先取走赢跟先取走输 都是抑或和 = 0 输了 只是先取走输要特判都是1的时候

#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
int main()  <br/>
{  <br/>
    int t, n;  <br/>
    scanf("%d" ,&amp;t);  <br/>
    while(t--)  <br/>
    {  <br/>
        scanf("%d", &amp;n);  <br/>
        int a, ans = 0, flag = 0;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            scanf("%d", &amp;a);  <br/>
            ans ^= a;  <br/>
            if(a &gt; 1)  //特判都是1 的时候  <br/>
               flag = 1;  <br/>
        }  <br/>
  <br/>
        if(!flag)  <br/>
        {  <br/>
            if(n%2) printf("Brother\n");  <br/>
            else printf("John\n");  <br/>
            continue;  <br/>
        }  <br/>
        if(ans == 0)  <br/>
            printf("Brother\n");  <br/>
        else  <br/>
            printf("John\n");  <br/>
威佐夫博弈<br/>
题目：有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取子? 

思路：威佐夫博弈，遇到奇异局势则必败第k个奇异局势(a(k), b(k))，a(k)是前面没有出现过的最小自然数（a(k)=(int)(k*(sqrt(5.0)+1)/2），b(k)=a(k)+k，采用适当的方法，这里不再证明，接下来只要判断就行了

同时从两堆中取相同数量的石头或者从一堆中取一定数量的石头，可以将非奇异局势变为奇异局势

#include &lt;cstdio&gt;  <br/>
#include &lt;cmath&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
  <br/>
double g = (sqrt(5.0) + 1) / 2;  // 黄金分割数1.618...  <br/>
  <br/>
int main()  <br/>
{  <br/>
    int a, b;  <br/>
    while(scanf("%d %d", &amp;a, &amp;b) == 2) {  <br/>
        if(a == 0 &amp;&amp; b == 0)  <br/>
            break;  <br/>
  <br/>
        int k = b - a;  <br/>
        if(a == (int)(g * k))    // 只要判断a即可，因为b=a+k是恒成立的  <br/>
        {  <br/>
            printf("0\n");  <br/>
        }  <br/>
        else  <br/>
        {  <br/>
            printf("1\n");  <br/>
            // 将非奇异局势变为奇异局势  <br/>
            for(int i=1; i&lt;=a; i++) // 同时从两堆中取相同数量的石头，注意这里是从1到a枚举  <br/>
            {  <br/>
                int x = a - i, y = b - i;  <br/>
                int k = y - x;  <br/>
                if(x == (int)(g * k))  <br/>
                    printf("%d %d\n", x, y);  <br/>
            }  <br/>
            for(int i=b-1; i&gt;=0; i--)   // 从一堆中取一定数量的石头，这里是从b-1往下枚举到0  <br/>
            {  <br/>
                int x = a, y = i;  <br/>
                if(x &gt; y)  <br/>
                    swap(x, y);  <br/>
  <br/>
                int k = y - x;  <br/>
                if(x == (int)(g * k))  <br/>
                    printf("%d %d\n", x, y);  <br/>
            }  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
巴什博弈<br/>
有三个数字n，p，q，表示一堆硬币一共有n枚，从这个硬币堆里取硬币，一次最少取p枚，最多q枚，如果剩下少于p枚就要一次取完。两人轮流取，直到堆里的硬币取完，最后一次取硬币的算输。对于每一行的三个数字，给出先取的人是否有必胜策略，如果有回答WIN，否则回答LOST

思路：<br/>
可以分成三种情况。<br/>
（1）如果n%(p+q)==0，那么A必胜。取胜步骤如下：<br/>
A第一次取q，接下去B取m，A就取p+q-m，那么最后剩下的就是p个硬币留给B取，B必败。<br/>
(2)如果n=(p+q)*k+s，(1&lt;=s&lt;=p),那么B必胜。取胜步骤如下：<br/>
A取一个m，那么B就取p+q-m，那么最后剩下的就是s个银币留给A取，A必败。<br/>
(3)如果n=(p+q)*k+s，(p&lt;s&lt;=q)，那么A必胜。取胜步骤如下：<br/>
A第一次取一个t，(1&lt;= s-t &lt;=p)，那么B取一个m，A取p+q-m,最后就剩下s-t个硬币留给B取，B得一次性取完，B必败。<br/>
（4）如果n=(p+q)*k+s，(q&lt;s&lt;=p+q)，那么A必胜。取胜步骤如下：<br/>
先取q，这样剩下了 s &lt; p，然后b取m，a跟着取p+q-m，最后剩下的m一定是b拿，所以a赢

简而言之就是：谁面对余数在1-p，谁就一定输，面对余数&gt;p都可以胜利，因为他可以一步变成余数小于p的，让对面面对余数在1-p

 <br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
using namespace std;  <br/>
int main()  <br/>
{  <br/>
    int n, p, q;  <br/>
    while(~scanf("%d%d%d",&amp;n, &amp;p, &amp;q))  <br/>
    {  <br/>
        if(n % (p+q) &lt;= p &amp;&amp; n % (p+q) &gt;= 1)  <br/>
            printf("LOST\n");  <br/>
        else  <br/>
            printf("WIN\n");  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
Tarjan算法<br/>
算法流程是： 开始先随机选一个点，沿着这个点进行遍历， dfn[]代表这个点出现的顺序，low[]代表强联通分量里编号最小的编号，以这个编号最小的节点作为联通分量的“起点”，每个节点low[]与dfn[]初始化时相同的，回溯时候更新low[u]=min(low[u],low[v])的值，如果对于一个子节点出现过（在栈里），说明转了一圈，在一个环里，那么就更新 low[u] = min(low[u], dfn[v])，最后栈里在每个dfn[x] == low[x]的关键点上面的非关键点都是与他一个联通分量的（因为之前说了我们让dfn最小的作为环的“起点”）。

缩点裸题<br/>
 

题目大意：N(2&lt;N&lt;100)各学校之间有单向的网络，每个学校得到一套软件后，可以通过单向网络向周边的学校传输，问题1：初始至少需要向多少个学校发放软件，使得网络内所有的学校最终都能得到软件。2，至少需要添加几条传输线路(边)，使任意向一个学校发放软件后，经过若干次传送，网络内所有的学校最终都能得到软件。 

也就是，给定一个有向图，求：

1) 至少要选几个顶点，才能做到从这些顶点出发，可以到达全部顶点

2) 至少要加多少条边，才能使得从任何一个顶点出发，都能到达全部顶点

—        顶点数&lt;= 100

解题思路：

—        1. 求出所有强连通分量

—        2. 每个强连通分量缩成一点，则形成一个有向无环图DAG。

—        3. DAG上面有多少个入度为0的顶点，问题1的答案就是多少

在DAG上要加几条边，才能使得DAG变成强连通的，问题2的答案就是多少

加边的方法：

要为每个入度为0的点添加入边，为每个出度为0的点添加出边

假定有 n 个入度为0的点，m个出度为0的点，如何加边？

把所有入度为0的点编号 0,1,2,3,4 ....N -1

每次为一个编号为i的入度0点可达的出度0点，添加一条出边，连到编号为(i+1)%N 的那个出度0点,

这需要加n条边

若 m &lt;= n，则

加了这n条边后，已经没有入度0点，则问题解决，一共加了n条边

若 m &gt; n，则还有m-n个入度0点，则从这些点以外任取一点，和这些点都连上边，即可，这还需加m-n条边。

所以，max(m,n)就是第二个问题的解

此外：当只有一个强连通分支的时候，就是缩点后只有一个点，虽然入度出度为0的都有一个，但是实际上不需要增加清单的项了，所以答案是1，0；

 

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;vector&gt;  <br/>
#include &lt;stack&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e3 + 5;  <br/>
int n, low[maxn], dfn[maxn], id[maxn], scc_cnt, dfs_cnt;  <br/>
int in[maxn], out[maxn];  <br/>
vector&lt;int&gt; v[maxn];  <br/>
stack&lt;int&gt; s;  <br/>
void init()  <br/>
{  <br/>
    memset(low, 0, sizeof(low));  <br/>
    memset(id, 0, sizeof(id));  <br/>
    memset(dfn, 0, sizeof(dfn));  <br/>
    memset(in, 0, sizeof(in));  <br/>
    memset(out, 0, sizeof(out));  <br/>
    scc_cnt = dfs_cnt = 0;  <br/>
    for(int i = 0; i &lt; maxn; i++)  <br/>
        v[i].clear();  <br/>
    while(!s.empty())  <br/>
        s.pop();  <br/>
}  <br/>
void tarjan(int x)  <br/>
{  <br/>
    dfn[x] = low[x] = ++dfs_cnt;  <br/>
    s.push(x);  <br/>
    for(int i = 0; i &lt; v[x].size(); i++)  <br/>
    {  <br/>
        int to = v[x][i];  <br/>
        if(!dfn[to])  <br/>
        {  <br/>
            tarjan(to);  <br/>
            low[x] = min(low[x], low[to]);  //回溯赋值<br/>
        }  <br/>
        else if(!id[to])   //这里是id == 0的在栈里，因为下面id赋值的都已经出栈了<br/>
            low[x] = min(low[x], dfn[to]);  //从这里把所有联通分量里的节点赋值成起点<br/>
    }  <br/>
    if(low[x] == dfn[x])  //从后往前回溯的时候，碰到一个关键节点说明他上面的都是一个联通分量<br/>
    {  <br/>
        scc_cnt++;  <br/>
        while(1)  <br/>
        {  <br/>
            int u = s.top();  <br/>
            s.pop();  <br/>
            id[u] = scc_cnt;  <br/>
            if(x == u) break;  <br/>
        }  <br/>
    }  <br/>
}  <br/>
void scc()  <br/>
{  <br/>
    for(int i = 1; i &lt;= n ; i++)  <br/>
        if(!dfn[i])  <br/>
            tarjan(i);  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    while(~scanf("%d", &amp;n))  <br/>
    {  <br/>
        init();  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            int x;  <br/>
            while(scanf("%d", &amp;x), x)  <br/>
                v[i].push_back(x);  <br/>
        }  <br/>
        scc();  <br/>
        if(scc_cnt == 1)  <br/>
        {  <br/>
            printf("1\n0\n");  <br/>
            continue;  <br/>
        }  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            for(int j = 0; j &lt; v[i].size(); j++)  <br/>
            {  <br/>
                int to = v[i][j];  <br/>
                if(id[i] != id[to])  <br/>
                {  <br/>
                    in[id[to]]++;  <br/>
                    out[id[i]]++;  <br/>
                }  <br/>
            }  <br/>
        }  <br/>
        int in_cnt = 0, out_cnt = 0;  <br/>
        for(int i = 1; i &lt;= scc_cnt; i++)  <br/>
        {  <br/>
            if(!in[i]) in_cnt++;  <br/>
            if(!out[i]) out_cnt++;  <br/>
        }  <br/>
        printf("%d\n%d\n", in_cnt, max(in_cnt, out_cnt));  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
强联通缩点的应用<br/>
 

题目大意：

给你N个炸弹，对应已知其坐标和爆炸范围，以及引爆这个炸弹需要的花费，对应如果引爆了炸弹a，没有引爆炸弹b，但是b炸弹在a炸弹的作用范围之内，那么b炸弹也会被引爆，问将所有炸弹都引爆需要的最小花费。

思路：

1、经典的最小点基的模型。我们首先O（n^2）预处理哪些炸弹可以被哪些炸弹引爆，得到一个有向图。

2、如果图中有有向环的话，我们可以将这一个有向环看成一个点，因为环内任意一个炸弹都能引爆这个环内所有的炸弹，所以我们使用Tarjan/Kosaraju之类的强连通算法缩点染色，使得图变成一个DAG（有向无环）图。

3、如果当前图变成了一个DAG图，那么度为0的节点一定是需要引爆的炸弹，因为这个节点中的炸弹不可能通过其他炸弹来引爆，只能通过直接引爆来达到引爆的目的，所以我们都将问题锁定在度为0的关键节点上来讨论，也就是所谓的最小点基问题。然后我们再简单分析一下，如果我们将所有度为0的节点都引爆了，那么度不为0的节点也一定会跟着被引爆，所以那么我们此时只需要将度为0的节点中找到一个对应的最小花费即可。

4、综上所述，我们Tarjan强联通缩点染色之后，找到度为0的节点，并且在其中找到花费最小的炸弹，累加即可。

 

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#include &lt;cmath&gt;  <br/>
#include &lt;vector&gt;  <br/>
#include &lt;stack&gt;  <br/>
typedef long long ll;  <br/>
using namespace std;  <br/>
const int maxn = 1e3 + 5;  <br/>
ll x[maxn], y[maxn], r[maxn];  <br/>
int n, low[maxn], dfn[maxn], id[maxn], scc_cnt, dfs_cnt, mincost[maxn], val[maxn], in[maxn];  <br/>
vector&lt;int&gt; v[maxn];  <br/>
stack&lt;int&gt; s;  <br/>
void init()  <br/>
{  <br/>
    memset(low, 0, sizeof(low));  <br/>
    memset(id, 0, sizeof(id));  <br/>
    memset(dfn, 0, sizeof(dfn));  <br/>
    memset(in, 0, sizeof(in));  <br/>
    memset(mincost, 0x3f3f3f3f, sizeof(mincost));  <br/>
    scc_cnt = dfs_cnt = 0;  <br/>
    for(int i = 0; i &lt; maxn; i++)  <br/>
        v[i].clear();  <br/>
    while(!s.empty())  <br/>
        s.pop();  <br/>
}  <br/>
void tarjan(int x)  <br/>
{  <br/>
    dfn[x] = low[x] = ++ dfs_cnt;  <br/>
    s.push(x);  <br/>
    for(int i = 0; i &lt; v[x].size(); i++)  <br/>
    {  <br/>
        int to = v[x][i];  <br/>
        if(!dfn[to])  <br/>
        {  <br/>
            tarjan(to);  <br/>
            low[x] = min(low[x], low[to]);  <br/>
        }  <br/>
        else if(!id[to])  <br/>
            low[x] = min(low[x], dfn[to]);  <br/>
    }  <br/>
    if(low[x] == dfn[x])  <br/>
    {  <br/>
        scc_cnt++;  <br/>
        while(1)  <br/>
        {  <br/>
            int u = s.top();  <br/>
            s.pop();  <br/>
            id[u] = scc_cnt;  <br/>
            mincost[scc_cnt] = min(mincost[scc_cnt], val[u]);  <br/>
            if(x == u) break;  <br/>
        }  <br/>
    }  <br/>
}  <br/>
void scc()  <br/>
{  <br/>
    for(int i = 1; i &lt;= n; i++)  <br/>
        if(!dfn[i])  <br/>
            tarjan(i);  <br/>
}  <br/>
int check(int i, int j)  <br/>
{  <br/>
    if((x[i]-x[j]) * (x[i]-x[j]) + (y[i]-y[j]) * (y[i]-y[j]) &lt;= r[i]*r[i])  <br/>
    {  <br/>
  <br/>
        return 1;  <br/>
    }  <br/>
    else  <br/>
        return 0;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int _, ca = 1;  <br/>
    cin &gt;&gt; _;  <br/>
    while(_--)  <br/>
    {  <br/>
        scanf("%d", &amp;n);  <br/>
        init();  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            scanf("%lld%lld%lld%d", &amp;x[i], &amp;y[i], &amp;r[i], &amp;val[i]);  <br/>
        }  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            for(int j = 1; j &lt;= n; j++)  <br/>
            {  <br/>
                if(check(i, j) &amp;&amp; i != j)  <br/>
                    v[i].push_back(j);  <br/>
            }  <br/>
        }  <br/>
        scc();  <br/>
        int ans = 0;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            for(int j = 0; j &lt; v[i].size(); j++)  <br/>
            {  <br/>
                int to = v[i][j];  <br/>
                if(id[i] != id[to])  <br/>
                {  <br/>
                    in[id[to]]++;  <br/>
                }  <br/>
            }  <br/>
        }  <br/>
        for(int i = 1; i &lt;= scc_cnt; i++)  <br/>
        {  <br/>
            if(in[i] == 0)  <br/>
                ans += mincost[i];  <br/>
        }  <br/>
        printf("Case #%d: %d\n",ca++, ans);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
最小生成树<br/>
prime<br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;queue&gt;  <br/>
using namespace std;  <br/>
const int maxn = 2e4 + 10;  //分开const  <br/>
const int maxm = 1e7 + 10;  <br/>
const int inf = 0x3f3f3f3f;  <br/>
int n, head[maxn], book[maxn], k, sum, dis[maxn];  <br/>
struct node  <br/>
{  <br/>
    int v, w, pre;  <br/>
    node(int vv, int ww) : v(vv), w(ww){}  <br/>
    node() {}  <br/>
    bool operator &lt; (const node &amp;a) const  <br/>
    {  <br/>
        return w &gt; a.w;  <br/>
    }  <br/>
}edge[maxm];  <br/>
void addedge(int u, int v, int w)  <br/>
{  <br/>
    edge[k].v = v;  <br/>
    edge[k].w = w;  <br/>
    edge[k].pre = head[u];  <br/>
    head[u] = k++;  <br/>
}  <br/>
void prim(int u)  <br/>
{  <br/>
    for(int i = 1; i &lt;= n; i++) dis[i] = inf;  <br/>
    dis[u] = 0;  <br/>
    priority_queue&lt;node&gt; pq;  <br/>
    pq.push(node(u,dis[u]));  <br/>
    while(!pq.empty())  <br/>
    {  <br/>
        u = pq.top().v;  <br/>
        pq.pop();  <br/>
        if(book[u]) continue;   //如果是1直接跳出，不加这个会超时  <br/>
        book[u] = 1;         <br/>
        sum += dis[u];  <br/>
        for(int i = head[u]; i != -1; i = edge[i].pre)  <br/>
        {  <br/>
            int v = edge[i].v, w = edge[i].w;  <br/>
            if(dis[v] &gt; w &amp;&amp; !book[v])  <br/>
            {  <br/>
                dis[v] = w;  <br/>
                pq.push(node(v,dis[v]));  <br/>
            }  <br/>
        }  <br/>
    }  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    while(~scanf("%d",&amp;n),n)  <br/>
    {  <br/>
        char str[maxn][8];  <br/>
        memset(book,0,sizeof(book));  <br/>
        memset(head,-1,sizeof(head));  <br/>
        k = 1, sum = 0;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            scanf("%s",str[i]);  <br/>
            for(int j = i; j &gt;= 1; j--)  <br/>
            {  <br/>
                int ans = 0;  <br/>
                for(int l = 0; l &lt; 7; l++)  <br/>
                {  <br/>
                    if(str[i][l] != str[j][l])  <br/>
                        ans++;  <br/>
                }  <br/>
                addedge(i,j,ans);  <br/>
                addedge(j,i,ans);  <br/>
            }  <br/>
        }  <br/>
        prim(1);  <br/>
        printf("The highest possible quality is 1/%d.\n", sum);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
Krusal<br/>
#include&lt;iostream&gt;  <br/>
#include&lt;cstdio&gt;  <br/>
#include&lt;cstring&gt;  <br/>
#include&lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e5+5;  <br/>
int n, m, r, k, pre[maxn];  <br/>
  <br/>
struct node  <br/>
{  <br/>
    int u, v, w;  <br/>
    node() {}  <br/>
    node(int uu, int vv, int ww): u(uu), v(vv), w(ww) {}  <br/>
    bool operator &lt; (const node &amp;a) const  <br/>
    {  <br/>
        return w &lt; a.w;  <br/>
    }  <br/>
}edge[maxn];  <br/>
  <br/>
int Find(int x)  <br/>
{  <br/>
    int r = x;  <br/>
    while(pre[r] != r) r = pre[r];  <br/>
    int i = x, j;  <br/>
    while(i != r)  <br/>
    {  <br/>
        j = pre[i];  <br/>
        pre[i] = r;  <br/>
        i = j;  <br/>
    }  <br/>
    return r;  <br/>
}  <br/>
  <br/>
bool join(int x, int y)  <br/>
{  <br/>
    int a = Find(x);  <br/>
    int b = Find(y);  <br/>
    if(a != b)  <br/>
    {  <br/>
        pre[b] = a;  <br/>
        return true;  <br/>
    }  <br/>
    return false;  <br/>
}  <br/>
  <br/>
int main(void)  <br/>
{  <br/>
    int t;  <br/>
    cin &gt;&gt; t;  <br/>
    while(t--)  <br/>
    {  <br/>
        k = 0;  <br/>
        scanf("%d%d%d", &amp;n, &amp;m, &amp;r);  <br/>
        for(int i = 0; i &lt; m+n; i++) pre[i] = i;  <br/>
        int R = r;  <br/>
        while(R--)  <br/>
        {  <br/>
            int u, v, w;  <br/>
            scanf("%d%d%d", &amp;u, &amp;v, &amp;w);  <br/>
            v += n;  <br/>
            w = -w;  <br/>
            edge[k++] = node(u, v, w);  <br/>
        }  <br/>
        sort(edge, edge+r);  <br/>
        int ans = (n+m)*10000, count = 0;  <br/>
        for(int i = 0; i &lt; r; i++)  <br/>
        {  <br/>
            if(join(edge[i].u, edge[i].v))  <br/>
            {  <br/>
                count++;  <br/>
                ans += edge[i].w;  <br/>
            }  <br/>
            if(count == n+m-1) break;  <br/>
        }  <br/>
        printf("%d\n", ans);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
匈牙利裸题<br/>
 

题意：

一些学生之间是朋友关系（关系不能传递），现在要将一堆学生分成两堆,使得在同一堆的学生之间没有朋友关系。如果不可以输出“No”，可以的话输出最多可以分出几对小盆友（最大匹配）。

思路：bfs判断二分图， 然后匈牙利。。。最后答案/2，因为是双向二分图

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#include &lt;queue&gt;  <br/>
using namespace std;  <br/>
const int maxn = 2e3 + 5;  <br/>
vector&lt;int&gt; v[maxn];  <br/>
int n, m, match[maxn], book[maxn];  <br/>
int judge()  <br/>
{  <br/>
    queue&lt;int&gt; q;  <br/>
    memset(book, -1, sizeof(book));  <br/>
    q.push(1);  <br/>
    book[1] = 0;  <br/>
    while(!q.empty())  <br/>
    {  <br/>
        int u = q.front();  <br/>
        q.pop();  <br/>
        for(int i = 0; i &lt; v[u].size(); i++)  <br/>
        {  <br/>
            int to = v[u][i];  <br/>
            if(book[to] == -1)  <br/>
            {  <br/>
                book[to] = !book[u];  <br/>
                q.push(to);  <br/>
            }  <br/>
            else if(book[to] == book[u])  <br/>
                return 0;  <br/>
        }  <br/>
    }  <br/>
    return 1;  <br/>
}  <br/>
int Find(int x)  <br/>
{  <br/>
    for(int i = 0; i &lt; v[x].size(); i++)  <br/>
    {  <br/>
        int to = v[x][i];  <br/>
        if(book[to]) continue;  <br/>
        book[to] = 1;  <br/>
        if(match[to] == 0 || Find(match[to]))  <br/>
        {  <br/>
            match[to] = x;  <br/>
            return 1;  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    while(~scanf("%d%d", &amp;n, &amp;m))  <br/>
    {  <br/>
        int x, y;  <br/>
        for(int i = 0; i &lt;= n; i++)  <br/>
            v[i].clear();  <br/>
        memset(match, 0, sizeof(match));  <br/>
        for(int i = 1; i &lt;= m; i++)  <br/>
        {  <br/>
            scanf("%d%d", &amp;x, &amp;y);  <br/>
            v[x].push_back(y);  <br/>
            v[y].push_back(x);  <br/>
        }  <br/>
        if(!judge())  <br/>
        {  <br/>
            printf("No\n");  <br/>
            continue;  <br/>
        }  <br/>
        int ans = 0;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            memset(book, 0, sizeof(book));  <br/>
            ans += Find(i);  <br/>
        }  <br/>
        printf("%d\n", ans/2);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
 

 

 

线段树

区间更新区间查询<br/>
 给你N个数，Q个操作，操作有两种，‘Q a b ’是询问a~b这段数的和，‘C a b c’是把a~b这段数都加上c。

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#define lch rt*2,l,m  <br/>
#define rch rt*2+1,m+1,r  <br/>
using namespace std;  <br/>
typedef long long ll;  <br/>
const int maxn = 1e6 + 5;  <br/>
ll tree[maxn*4], mark[maxn*4];  <br/>
void pushup(int rt)   //向上传递<br/>
{  <br/>
    tree[rt] = tree[rt*2+1] + tree[rt*2];   //这里是等于  <br/>
}  <br/>
void pushdown(int rt, int l, int r)   //向下传递<br/>
{  <br/>
    int m = (l+r)/2;  <br/>
    mark[rt*2] += mark[rt];  //这里都是+=  <br/>
    tree[rt*2] += mark[rt]*(m-l+1);  <br/>
    mark[rt*2+1] += mark[rt];  <br/>
    tree[rt*2+1] += mark[rt]*(r-m);  <br/>
    mark[rt] = 0;  //不要忘记最后给mark变成0  <br/>
}  <br/>
void build(int rt, int l, int r)  <br/>
{  <br/>
    if(l == r)  <br/>
    {  <br/>
        scanf("%lld", &amp;tree[rt]);  <br/>
        return;  <br/>
    }  <br/>
    int m = (l+r)/2;  <br/>
    build(lch);  <br/>
    build(rch);  <br/>
    pushup(rt);  //更新  <br/>
}  <br/>
void update(int rt, int l, int r, int i, int j, int val)   <br/>
{  <br/>
    if(l &gt;= i &amp;&amp; r &lt;= j)   //一定要去见覆盖  <br/>
    {  <br/>
        tree[rt] += (r-l+1)*val; //这里是 +=  <br/>
        mark[rt] += val;  <br/>
        return;  <br/>
    }  <br/>
    if(mark[rt]) pushdown(rt,l,r);  <br/>
    int m = (l+r)/2;  <br/>
    if(i &lt;= m) update(lch,i,j, val);  <br/>
    if(j &gt; m) update(rch,i,j, val);  <br/>
    pushup(rt);   //这里要更新  <br/>
}  <br/>
ll query(int rt, int l, int r, int i, int j)  <br/>
{  <br/>
    if(l &gt;= i &amp;&amp; r &lt;= j)  //区间覆盖  <br/>
    {  <br/>
        return tree[rt];  <br/>
    }  <br/>
    if(mark[rt]) pushdown(rt,l,r);  <br/>
    int m = (l+r)/2;  <br/>
    ll ans = 0;  <br/>
    if(i &lt;= m) ans += query(lch,i,j);  <br/>
    if(j &gt; m) ans += query(rch,i,j);  <br/>
    return ans;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int n, m;  <br/>
    while(~scanf("%d%d", &amp;n, &amp;m))  <br/>
    {  <br/>
        memset(mark, 0, sizeof(mark));  <br/>
        build(1,1,n);  <br/>
        char cmd;  <br/>
        int i, j, val;  <br/>
        while(m--)  <br/>
        {  <br/>
            scanf(" %c", &amp;cmd);  <br/>
            if(cmd == 'Q')  <br/>
            {  <br/>
                scanf("%d%d", &amp;i, &amp;j);  <br/>
                printf("%lld\n", query(1,1,n,i,j));  <br/>
            }  <br/>
            else  <br/>
            {  <br/>
                scanf("%d%d%d", &amp;i, &amp;j, &amp;val);  <br/>
                update(1, 1, n, i, j, val);  <br/>
            }  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
DP<br/>
求最大子矩阵<br/>
总的来说就是 n2枚举所有列的组合， 然后求出每一行在这两列之间的和（这里随着j的移动求就好了，o1复杂度，不比再一个for从头枚举）， 答案就是 最大子段和了， 求一段连续的区间，让他们和最大， 只不过这里区间每个数代表的是一段数的和， 巧妙的将n5复杂度的算法通过枚举变成了n3了~

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 505;  <br/>
int a[maxn][maxn], sum[maxn];  <br/>
int main()  <br/>
{  <br/>
    int m, n;  <br/>
    scanf("%d%d", &amp;m, &amp;n);  <br/>
    for(int i = 1; i &lt;= n; i++)  <br/>
        for(int j = 1; j &lt;= m; j++)  <br/>
            scanf("%d", &amp;a[i][j]);  <br/>
    int cur = 0, ans = 0;  <br/>
    for(int i = 1; i &lt;= m; i++)  <br/>
    {  <br/>
        for(int j = i; j &lt;= m; j++)  <br/>
        {  <br/>
            cur = 0;  <br/>
            for(int k = 1; k &lt;= n; k++)  <br/>
            {  <br/>
                sum[k] = i == j ? a[k][j] : sum[k]+a[k][j];  <br/>
                cur += sum[k];  <br/>
                if(cur &lt; 0) cur = 0;  //这里要求负数输出0，所以ans在cur后面<br/>
                ans = max(ans, cur);  <br/>
            }  <br/>
        }  <br/>
    }  <br/>
    printf("%d\n", ans);  <br/>
    return 0;  <br/>
}  <br/>
最大子段和<br/>
int maxsubsum (int a[])  <br/>
{  <br/>
    S = 0;  <br/>
    maxsum  = 0;  <br/>
    cursum = 0;  <br/>
    for(int i = 0 ; i &lt; len ; i++)  <br/>
    {  <br/>
        cursum += a[i];  <br/>
        if(cursum &lt; 0)   {cursum = 0;  S = i + 1;}      //  如果小于0  起始点就在他的后面一位  <br/>
        if(maxsum &lt; cursum)  {maxsum = cursum;  s = S ; e = i;}   //  s e用来记录起始点与末尾点  <br/>
  <br/>
    }  <br/>
    return maxsum;  <br/>
}  <br/>
最长公共子序列<br/>
//最长公共子序列（可不连续）  <br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
int dp[105][105];  //记录当前字母“前面”的最长子序列的长度  <br/>
char a[100], b[100];  <br/>
int path[150];  <br/>
int main()  <br/>
{  <br/>
    while(cin &gt;&gt; a &gt;&gt; b)  <br/>
    {  <br/>
        int len1 = strlen(a);  <br/>
        int len2 = strlen(b);  <br/>
        for(int i = 1; i &lt;= len1; i++)  //i，j从一开始  <br/>
            for(int j = 1; j &lt;= len2; j++)  <br/>
        {  <br/>
            if(a[i-1] == b[j-1])        //前一个相同，当前的就是前面dp+1；  <br/>
                dp[i][j] = dp[i-1][j-1] + 1;  <br/>
            else  <br/>
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);  <br/>
        }  <br/>
        cout &lt;&lt; dp[len1][len2] &lt;&lt; endl;  <br/>
｝<br/>
最长公共子串<br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
int dp[105][105];  //记录当前字母“前面”的最长子序列的长度  <br/>
char a[100], b[100];  <br/>
int main()  <br/>
{  <br/>
    while(cin &gt;&gt; a &gt;&gt; b)  <br/>
    {  <br/>
        int max1 = 0, temp;  <br/>
        memset(dp,0,sizeof(dp));  <br/>
        int len1 = strlen(a), len2 = strlen(b);  <br/>
        for(int i = 1; i &lt;= len1; i++)  <br/>
            for(int j = 1; j &lt;= len2; j++)  <br/>
            {  <br/>
                 if(a[i-1] == b[j-1])  dp[i][j] = dp[i-1][j-1] + 1;  <br/>
                 else dp[i][j] = 0;  <br/>
                 if(max1 &lt; dp[i][j])  <br/>
                 {  <br/>
                    max1 = dp[i][j]; //纪录dp[][]中的最大值  <br/>
                    temp = i;//纪录最长公共子串的末端在str1中的位置(也可以纪录在str2中的位置)  <br/>
                 }  <br/>
            }  <br/>
        for(int i = temp - max1; i &lt; temp; i++)  <br/>
            cout &lt;&lt; a[i];  <br/>
            cout &lt;&lt; endl;  <br/>
    }  <br/>
  <br/>
}  <br/>
LIS<br/>
方法1（n^2）：设f(i)表示L中以ai为末元素的最长递增子序列的长度。则有如下的递推方程：

这个递推方程的意思是，在求以ai为末元素的最长递增子序列时，找到所有序号在L前面且小于ai的元素aj，即j&lt;i且aj&lt;ai。如果这样的元素存在，那么对所有aj,都有一个以aj为末元素的最长递增子序列的长度f(j)，把其中最大的f(j)选出来，那么f(i)就等于最大的f(j)加上1，即以ai为末元素的最长递增子序列，等于以使f(j)最大的那个aj为末元素的递增子序列最末再加上ai；如果这样的元素不存在，那么ai自身构成一个长度为1的以ai为末元素的递增子序列。

方法2(nlogn)：在第1种算法中，在计算每一个f(i)时，都要找出最大的f(j)(j&lt;i）来，由于f(j)没有顺序，只能顺序查找满足aj&lt;ai最大的f(j)，如果能将让f(j)有序，就可以使用二分查找，这样算法的时间复杂度就可能降到O(nlogn)。于是想到用一个数组B来存储“子序列的”最大增子序列的最末元素，即有B[f(j)] = aj在计算f(i)时，在数组B中用二分查找法找到满足j&lt;i且B[f(j)]=aj&lt;ai的最大的j,并将B[f[j]+1]置为ai,如果j不是最后一个位置，那么说明a[i]比a[j+1]小，所以把a[j+1]换成a[i]，使lis可能性更大。

#include&lt;iostream&gt;  <br/>
#include&lt;cstdio&gt;  <br/>
#include&lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1005;  <br/>
int a[maxn], b[maxn], dp[maxn];  <br/>
int main(void)  <br/>
{  <br/>
    int n;  <br/>
    while(cin &gt;&gt; n)  <br/>
    {  <br/>
        for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), dp[i] = 1;  <br/>
        int Len = 1, l, m, r;  <br/>
        b[1] = a[0];  <br/>
        for(int i = 1; i &lt; n; i++)  <br/>
        {  <br/>
            l = 1, r = Len;  <br/>
            while(l &lt;= r)  <br/>
            {  <br/>
                m = (l+r)/2;  <br/>
                if(b[m] &lt; a[i]) l = m+1;  <br/>
                else r = m-1;  <br/>
            }  <br/>
            b[l] = a[i];  <br/>
            if(l &gt; Len) Len++;  <br/>
        }  <br/>
        printf("%d\n", Len);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
输出路径

#include&lt;iostream&gt;  <br/>
#include&lt;cstdio&gt;  <br/>
using namespace std;  <br/>
const int maxn = 10005;  <br/>
int a[maxn], dp[maxn], pre[maxn], path[maxn],  ans, e;  <br/>
int main(void)  <br/>
{  <br/>
    int n;  <br/>
    while(cin &gt;&gt; n)  <br/>
    {  <br/>
        for(int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]), dp[i] = 1, pre[i] = -1;  <br/>
        ans = 1;    //初始最大长度为1，结尾在a[0]  <br/>
        e = 0;  <br/>
        for(int i = 1; i &lt; n; i++)  <br/>
            for(int j = 0; j &lt; i; j++)  <br/>
                if(a[j] &lt; a[i] &amp;&amp; dp[j]+1 &gt; dp[i])  <br/>
                {  <br/>
                    dp[i] = dp[j]+1;  <br/>
                    pre[i] = j;     //记录每个点i的上一个最长序列，存在已他自己为下标的pre里  <br/>
                    if(dp[i] &gt; ans) ans = dp[i], e = i;    //因为是&gt;,而不是&gt;=所以最后一个元素肯定是所有里面最前面的  <br/>
                }  <br/>
        printf("%d\n", ans);  <br/>
        //路径要逆推回去  <br/>
        for(int i = 0, k = ans; i &lt; ans; i++)  <br/>
        {  <br/>
            path[k--] = a[e];   //从后往前推，最后一个节点为e；把他的值a【e】输出了  <br/>
            e = pre[e];     //pre【e】存了上一个他的节点，也就是他之前最长的长度的最后一个字母  <br/>
        }  <br/>
        for(int i = 1; i &lt;= ans; i++)  <br/>
        {  <br/>
            if(i-1) printf(" ");  <br/>
            printf("%d", path[i]);  <br/>
        }  <br/>
        printf("\n");  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
LICS<br/>
 

定义状态

F[i][j]表示以a串的前i个整数与b串的前j个整数且以b[j]为结尾构成的LCIS的长度。

状态转移方程：

①F[i][j] = F[i-1][j] (a[i] != b[j])

②F[i][j] = max(F[i-1][k]+1) (1 &lt;= k &lt;= j-1 &amp;&amp; b[j] &gt; b[k])

现在我们来说为什么会是这样的状态转移方程呢？

对于①，因为F[i][j]是以b[j]为结尾的LCIS，如果F[i][j]&gt;0那么就说明a[1]..a[i]中必然有一个整数a[k]等于b[j],因为a[k]!=a[i]，那么a[i]对F[i][j]没有贡献，于是我们不考虑它照样能得出F[i][j]的最优值。所以在a[i]!=b[j]的情况下必然有F[i][j]=F[i-1][j]。

对于②，前提是a[i] == b[j],我们需要去找一个最长的且能让b[j]接在其末尾的LCIS。之前最长的LCIS在哪呢？首先我们要去找的F数组的第一维必然是i-1。因为i已经拿去和b[j]配对去了，不能用了。并且也不能是i-2，因为i-1必然比i-2更优。第二维呢？那就需要枚举b[1]...b[j-1]了，因为你不知道这里面哪个最长且哪个小于b[j]。这里还有一个问题，可不可能不配对呢？也就是在a[i]==b[j]的情况下，需不需要考虑F[i][j]=F[i-1][j]的决策呢？答案是不需要。因为如果b[j]不和a[i]配对，那就是和之前的a[1]...a[j-1]配对（假设F[i-1][j]&gt;0，等于0不考虑），这样必然没有和a[i]配对优越。（为什么必然呢？因为b[j]和a[i]配对之后的转移是max(F[i-1][k])+1，而和之前的i`配对则是max(F[i`-1][k])+1。

 

以上的代码的时间复杂度是O(n^3)，那我们怎么去优化呢？通过思考发现，第三层循环找最大值是否可以优化呢？我们能否直接把枚举最大的f[i-1][k]值直接算出来呢？假设存在这么一个序列a[i] == b[j],我们继续看状态转移方程②，会发现b[j] &gt; b[k]，即当a[i] == b[j]时，可以推出a[i] &gt; b[k]，那么有了这个表达式我们可以做什么呢？可以发现，我们可以维护一个MAX值来储存最大的f[i-1][k]值。即只要有a[i] &gt; a[j]的地方，那么我们就可以更新最大值，所以，当a[i] == b[j]的时候，f[i][j] = MAX+1，即可

<br/>
可以发现，其实上面的代码有些地方与0/1背包很相似，即每次用到的只是上一层循环用到的值，即f[i-1][j]，那么我们可以像优化0/1背包问题利用滚动数组来优化空间。如果是求最长公共下降子序列呢？很明显嘛，把状态定义改动一下，即f[i][j]表示以a串的前i个整数与b串的前j个整数且以b[j]为结尾构成的LCDS的长度，具体实现的时候只要把a[i] &gt; b[j]改为a[i] &lt; b[j]就可以啦。

 

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 5e2 + 5;  <br/>
int dp[maxn], a[maxn], b[maxn], n, m;  <br/>
int main()  <br/>
{  <br/>
    int t;  <br/>
    cin &gt;&gt; t;  <br/>
    while(t--)  <br/>
    {  <br/>
        memset(dp, 0, sizeof(dp));  <br/>
        scanf("%d", &amp;n);  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
            scanf("%d", &amp;a[i]);  <br/>
        scanf("%d", &amp;m);  <br/>
        for(int i = 1; i &lt;= m; i++)  <br/>
            scanf("%d", &amp;b[i]);  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            int maxx = 0;  <br/>
            for(int j = 1; j &lt;= m; j++)  <br/>
            {  <br/>
                if(a[i] &gt; b[j]) maxx = max(maxx, dp[j]);  <br/>
                if(a[i] == b[j]) dp[j] = maxx + 1;  <br/>
            }  <br/>
        }  <br/>
        int ans = 0;  <br/>
        for(int i = 1; i &lt;= m; i++)  <br/>
            ans = max(ans, dp[i]);  <br/>
        if(t != 0)  <br/>
            printf("%d\n\n", ans);  <br/>
        else  <br/>
            printf("%d\n", ans);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
记录路径

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 505;  <br/>
int n, m, t, a[maxn], b[maxn], dp[maxn][maxn], pathx[maxn][maxn], pathy[maxn][maxn], cur, ans;  <br/>
void Printf(int x, int y)  <br/>
{  <br/>
    if(dp[x][y] == 0)  <br/>
        return;  <br/>
    if(pathx[x][y] != -1 &amp;&amp; pathy[x][y] != -1)  <br/>
    {  <br/>
        int tx = pathx[x][y];  <br/>
        int ty = pathy[x][y];  <br/>
        Printf(tx, ty);  <br/>
        if(dp[x][y] != dp[tx][ty] &amp;&amp; y != 0)  <br/>
        {  <br/>
            cur++;  <br/>
            if(cur &lt; ans)  <br/>
                printf("%d ", b[y]);  <br/>
            else  <br/>
                printf("%d\n", b[y]);  <br/>
        }  <br/>
    }  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    cin &gt;&gt; t;  <br/>
    while(t--)  <br/>
    {  <br/>
        scanf("%d", &amp;n);  <br/>
        for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]);  <br/>
        scanf("%d", &amp;m);  <br/>
        for(int i = 1; i &lt;= m; i++) scanf("%d", &amp;b[i]);  <br/>
        memset(dp, 0, sizeof(dp));  <br/>
        memset(pathx, -1, sizeof(pathx));  <br/>
        memset(pathy, -1, sizeof(pathy));  <br/>
        int tmpx = 0, tmpy = 0;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            tmpx = 0, tmpy = 0;  <br/>
            int maxx = 0;  <br/>
            for(int j = 1; j &lt;= m; j++)  <br/>
            {  <br/>
                dp[i][j] = dp[i-1][j];  <br/>
                pathx[i][j] = i-1;  <br/>
                pathy[i][j] = j;  <br/>
                if(a[i] &gt; b[j] &amp;&amp; maxx &lt; dp[i-1][j]) maxx = dp[i-1][j], tmpx = i-1, tmpy = j;  <br/>
                if(a[i] == b[j]) dp[i][j] = maxx+1, pathx[i][j] = tmpx, pathy[i][j] = tmpy;  <br/>
            }  <br/>
        }  <br/>
        ans = 0;  <br/>
        int flag = -1;  <br/>
        for(int i = 1; i &lt;= m; i++)  <br/>
        {  <br/>
            if(ans &lt; dp[n][i])  <br/>
            {  <br/>
                flag = i;  <br/>
                ans = dp[n][i];  <br/>
            }  <br/>
        }  <br/>
        printf("%d\n", ans);  <br/>
        tmpx = n, tmpy = flag;  <br/>
        cur = 0;  <br/>
        if(tmpy &gt; 0)  <br/>
            Printf(tmpx, tmpy);  <br/>
        if(t != 0)  <br/>
            puts("");  <br/>
    }  <br/>
  <br/>
    return 0;  <br/>
}  <br/>
 

矩阵取数（多线程DP）<br/>
 

 

设有N*N的方格图(N&lt;=10,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：

 某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。

n^4

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int maxn = 15;  <br/>
int dp[maxn][maxn][maxn][maxn], table[maxn][maxn];  <br/>
int main()  <br/>
{  <br/>
    int n, x, y, v;  <br/>
    scanf("%d", &amp;n);  <br/>
    while(scanf("%d%d%d", &amp;x,&amp;y,&amp;v), x+y+v)  <br/>
    {  <br/>
        table[x][y] = v;  <br/>
    }  <br/>
    for(int x1 = 1; x1 &lt;= n; x1++)  <br/>
    for(int y1 = 1; y1 &lt;= n; y1++)  <br/>
    for(int x2 = 1; x2 &lt;= n; x2++)  <br/>
    for(int y2 = 1; y2 &lt;= n; y2++)  <br/>
    {  <br/>
        dp[x1][y1][x2][y2] = max(max(dp[x1-1][y1][x2-1][y2], dp[x1-1][y1][x2][y2-1]),max(dp[x1][y1-1][x2-1][y2], dp[x1][y1-1][x2][y2-1]))+table[x1][y1];  <br/>
        if(x1 != x2 &amp;&amp; y1 != y2) dp[x1][y1][x2][y2] += table[x2][y2];  <br/>
    }  <br/>
    cout &lt;&lt; dp[n][n][n][n] &lt;&lt; endl;  <br/>
    return 0;  <br/>
}  <br/>
n^3

思路：多线程dp，dp[i][j][k]，i代表步数，其实我觉得是做过的行与列的总和比较好，j代表第一遍走了i步，他在第几列，k代表第二边走了i步他在第几列。。。根据步数还有列数可以推出行数，三元函数是为了让他们不重复

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 205;  <br/>
int dp[maxn*2][maxn][maxn], a[maxn][maxn];  <br/>
int main()  <br/>
{  <br/>
    int n, m;  <br/>
    scanf("%d%d", &amp;m, &amp;n);  <br/>
    for(int i = 1; i &lt;= n; i++)  <br/>
        for(int j = 1; j &lt;= m; j++)  <br/>
            scanf("%d", &amp;a[i][j]);  <br/>
//    dp[0][0][0] = a[1][1];  <br/>
    int ans = 0;  <br/>
    for(int i = 2; i &lt;= m+n; i++)  <br/>
    {  <br/>
        for(int j = 1; j &lt;= min(i,m); j++)  <br/>
            for(int k = 1; k &lt;= min(i,m); k++)  <br/>
            {  <br/>
                dp[i][j][k] = dp[i-1][j][k];  <br/>
                if(j) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]);  <br/>
                if(k) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]);  <br/>
                if(k &amp;&amp; j) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]);  <br/>
                dp[i][j][k] = dp[i][j][k] + (j == k ? a[i-j][j] : a[i-j][j] + a[i-k][k]);  <br/>
                ans = max(ans, dp[i][j][k]);  <br/>
            }  <br/>
    }  <br/>
    printf("%d\n", ans);  <br/>
    return 0;  <br/>
}  <br/>
背包模板<br/>
hdu2546 普通01背包，只是重量跟价值相同罢了,完全背包就只是把里面那个逆循环正过来就行

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e3 + 5;  <br/>
int dp[maxn],a[maxn];  <br/>
int main()  <br/>
{  <br/>
    int n, m, sum, max1;  <br/>
    while(~scanf("%d",&amp;n) &amp;&amp; n)  <br/>
    {  <br/>
        memset(dp,0,sizeof(dp));  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
            scanf("%d",&amp;a[i]);  <br/>
        scanf("%d",&amp;m);  <br/>
        if(m &lt; 5) {printf("%d\n",m); continue;}  <br/>
        sort(a+1,a+1+n);  <br/>
        m -= 5;  <br/>
        for(int i = 1; i &lt; n; i++)  <br/>
            for(int j = m; j &gt;= a[i]; j--)  <br/>
            {  <br/>
                dp[j] = max(dp[j],dp[j-a[i]]+a[i]);  <br/>
            }  <br/>
        printf("%d\n",m-dp[m]+5-a[n]);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
hdu 2191 多重背包模板（普通的）

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
using namespace std;  <br/>
const int maxn = 105;  <br/>
int dp[maxn], v[maxn], w[maxn], c[maxn];  <br/>
int main()  <br/>
{  <br/>
    int C, n, m;  <br/>
    scanf("%d",&amp;C);  <br/>
    while(C--)  <br/>
    {  <br/>
        scanf("%d%d",&amp;n,&amp;m);  <br/>
        for(int i = 1; i &lt;= m; i++)  <br/>
            scanf("%d%d%d",&amp;v[i],&amp;w[i],&amp;c[i]);  <br/>
        memset(dp,0,sizeof(dp));  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            for(int k = 1; k &lt;= c[i]; k++)    //有c[i]个就循环c[i]次呗  <br/>
            {  <br/>
                for(int j = n; j &gt;= v[i]; j--)  <br/>
                {  <br/>
                    dp[j] = max(dp[j],dp[j-v[i]] + w[i]);  <br/>
                }  <br/>
            }  <br/>
        }  <br/>
        printf("%d\n",dp[n]);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
二进制多重背包

#include&lt;iostream&gt;  <br/>
#include&lt;cstdio&gt;  <br/>
#include&lt;cstring&gt;  <br/>
#include&lt;string&gt;  <br/>
using namespace std;  <br/>
int main()  <br/>
{  <br/>
    int C;  <br/>
    int n,m;  <br/>
    int i,j,k;  <br/>
    int p[600],h[600],c[600];//价格，重量，袋数  <br/>
    int w[600],v[600];//重新分配  <br/>
    int dp[10005];  <br/>
    int index;  <br/>
    scanf("%d",&amp;C);  <br/>
    while(C--)  <br/>
    {  <br/>
        memset(dp,0,sizeof(dp));  <br/>
        scanf("%d%d",&amp;n,&amp;m);  <br/>
        index = 1;  <br/>
        for(i = 1; i &lt;= m; i++)  <br/>
        {  <br/>
            scanf("%d%d%d",&amp;p[i],&amp;h[i],&amp;c[i]);  <br/>
            //利用二进制分解法，拆解物品，转化成01背包  <br/>
            for(j = 1; j &lt;= c[i]; j &lt;&lt;= 1)  <br/>
            {  <br/>
                v[index] = j*p[i];  <br/>
                w[index++] = j*h[i];  <br/>
                c[i] -= j;  <br/>
            }  <br/>
            //不能正好分解的有剩余的部分单独作为一个物品。  <br/>
            if(c[i]&gt;0)  <br/>
            {  <br/>
                v[index] = c[i]*p[i];  <br/>
                w[index++] = c[i]*h[i];  <br/>
            }  <br/>
        }  <br/>
        //01背包  <br/>
        for(i = 1; i &lt; index; i++)  <br/>
        {  <br/>
            for(j = n; j &gt;=v[i]; j--)  <br/>
            {  <br/>
                dp[j]=max(dp[j],dp[j-v[i]]+w[i]);  <br/>
            }  <br/>
        }  <br/>
        printf("%d\n",dp[n]);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
 

并查集<br/>
就是用并查集求出有几个集合，每个集合的值是多少，裸题，别把sum[Find(x)] += sum[Find(y)]写成 sum[x] += sum[y] 了  

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e3 + 5;  <br/>
int n, m, pre[maxn], sum[maxn], sum2[maxn], book[maxn][maxn];  <br/>
int Find(int x)  <br/>
{  <br/>
    return pre[x] == x ? x : pre[x] = Find(pre[x]);  <br/>
}  <br/>
void join(int x, int y)  <br/>
{  <br/>
    if(Find(y) != Find(x))  <br/>
        sum[Find(x)] += sum[Find(y)];  <br/>
    pre[Find(y)] = Find(x);  <br/>
  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int t, ca = 1;  <br/>
    scanf("%d", &amp;t);  <br/>
    while(t--)  <br/>
    {  <br/>
//        memset(book, 0, sizeof(book));  <br/>
        scanf("%d%d", &amp;n, &amp;m);  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
        {  <br/>
            scanf("%d", &amp;sum[i]);  <br/>
            pre[i] = i;  <br/>
        }  <br/>
        int u, v;  <br/>
        while(m--)  <br/>
        {  <br/>
            scanf("%d%d", &amp;u, &amp;v);  <br/>
            join(u, v);  <br/>
        }  <br/>
        int ans = 0, index = 1;  <br/>
        for(int i = 1; i &lt;= n; i++)  <br/>
            if(pre[i] == i)  <br/>
                ans++, sum2[index++] = sum[i];  <br/>
        printf("Case %d: %d\n", ca++, ans);  <br/>
        sort(sum2+1,sum2+index);  <br/>
        for(int i = 1; i &lt;= ans; i++)  <br/>
        {  <br/>
            printf("%d%c", sum2[i], i == ans ? '\n' : ' ');  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
字符串<br/>
马拉车<br/>
原理解释

#include &lt;cstdio&gt;  <br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int maxn = 100005;  <br/>
char str[maxn];  <br/>
char temp[maxn*2];  <br/>
int l[maxn*2];  <br/>
void malache(char *str)  <br/>
{  <br/>
    int len = strlen(str);  <br/>
    temp[0]='￥';  <br/>
    temp[1]='#';  <br/>
    for(int i = 0; i &lt; len ; i++)  <br/>
    {  <br/>
        temp[(i+1)*2] = str[i];  <br/>
        temp[(i+1)*2+1] = '#';  <br/>
    }  <br/>
    int mx = 0, po = 0,ans = 0;  <br/>
    for(int i = 0;i &lt;= 2*len+1; i++)  <br/>
    {  <br/>
        if(i &lt; mx)   l[i] = min(l[2*po-i],mx-i);  <br/>
        else l[i] = 1;  <br/>
        while(temp[i-l[i]] == temp[i+l[i]])  l[i]++;  <br/>
        if(l[i]+i &gt; mx)   {po = i; mx = l[i]+i;}  <br/>
        ans = max(ans , l[i]);  <br/>
    }  <br/>
    cout &lt;&lt; ans - 1 &lt;&lt;endl;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int t;  <br/>
    cin &gt;&gt; t;  <br/>
    while(t--)  <br/>
    {  <br/>
        memset(temp,0,sizeof(temp));  <br/>
        cin &gt;&gt; str;  <br/>
        malache(str);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
kmp<br/>
原理解释

例题

对主串做next数组<br/>
#include&lt;bits/stdc++.h&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1005;  <br/>
char s[maxn], t[maxn];  <br/>
int Next[maxn], ans;  <br/>
  <br/>
void makeNext(void)  <br/>
{  <br/>
    int len = strlen(s);  <br/>
    Next[0] = Next[1] = 0;  <br/>
    for(int i = 1; i &lt; len; i++)  <br/>
    {  <br/>
        int j = Next[i];  <br/>
        while(j &amp;&amp; s[i] != s[j]) j = Next[j];  <br/>
        Next[i+1] = s[i]==s[j] ? j+1 : 0;  <br/>
    }  <br/>
}  <br/>
  <br/>
void kmp(void)  <br/>
{  <br/>
    int len1 = strlen(s);  <br/>
    int len2 = strlen(t);  <br/>
    int i, j = 0;  <br/>
    for(int i = 0; i &lt; len1; i++)  <br/>
    {  <br/>
        while(j &amp;&amp; s[i] != t[j]) j = Next[j];  <br/>
        if(s[i] == t[j]) j++;  <br/>
        if(j == len2) ans++, j = 0;  <br/>
    }  <br/>
}  <br/>
  <br/>
int main(void)  <br/>
{  <br/>
    while(~scanf(" %s", s))  <br/>
    {  <br/>
        if(strlen(s) == 1 &amp;&amp; s[0] == '#') break;  <br/>
        scanf(" %s", t);  <br/>
        ans = 0;  <br/>
        makeNext();  <br/>
        kmp();  <br/>
        printf("%d\n", ans);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
对子串做next数组<br/>
#include&lt;cstdio&gt;<br/>
#include&lt;cstring&gt;<br/>
using namespace std;<br/>
const int N=1e6+5;<br/>
int n,m,p,next[N],a[N],b[N];<br/>
void getnext()<br/>
{<br/>
    int i=0,j=-1;<br/>
    next[i]=j;<br/>
    while(i&lt;m)<br/>
    {<br/>
        if(j==-1||b[i]==b[j])<br/>
        {<br/>
            i++;<br/>
            j++;<br/>
            next[i]=j;<br/>
        }<br/>
        else<br/>
            j=next[j];<br/>
    }<br/>
}<br/>
int kmp()<br/>
{<br/>
    int res=0;<br/>
    getnext();<br/>
    for(int k=0;k&lt;p;++k){//进行p次匹配 <br/>
        int i=k,j=0;<br/>
        while(i&lt;n)<br/>
        {<br/>
            if(j==-1||a[i]==b[j])<br/>
            {<br/>
                i+=p;//在母串上每隔p个位置匹配一次 <br/>
                j++;<br/>
                if(j==m)<br/>
                    res++;<br/>
            }<br/>
            else<br/>
                j=next[j];<br/>
        }<br/>
    }<br/>
    return res;<br/>
}<br/>
int main()<br/>
{<br/>
    int T;<br/>
    scanf("%d",&amp;T);<br/>
    for(int kase=1;kase&lt;=T;kase++)<br/>
    {<br/>
        scanf("%d%d%d",&amp;n,&amp;m,&amp;p);<br/>
        memset(next,0,sizeof(next));<br/>
        memset(b,0,sizeof(b));//注意要清空b数组，这里WA了两发，迷之耽误一个小时 <br/>
        memset(a,0,sizeof(a));<br/>
        for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]);<br/>
        for(int i=0;i&lt;m;i++)scanf("%d",&amp;b[i]);<br/>
        printf("Case #%d: %d\n",kase,kmp());<br/>
    }<br/>
    return 0;<br/>
}<br/>
 

 

 

 

扩展KMP<br/>
点击打开链接

const int maxn=100010;   //字符串长度最大值<br/>
int next[maxn],ex[maxn]; //ex数组即为extend数组<br/>
//预处理计算next数组<br/>
void GETNEXT(char *str)<br/>
{<br/>
    int i=0,j,po,len=strlen(str);<br/>
    next[0]=len;//初始化next[0]<br/>
    while(str[i]==str[i+1]&amp;&amp;i+1&lt;len)//计算next[1]<br/>
    i++;<br/>
    next[1]=i;<br/>
    po=1;//初始化po的位置<br/>
    for(i=2;i&lt;len;i++)<br/>
    {<br/>
        if(next[i-po]+i&lt;next[po]+po)//第一种情况，可以直接得到next[i]的值<br/>
        next[i]=next[i-po];<br/>
        else//第二种情况，要继续匹配才能得到next[i]的值<br/>
        {<br/>
            j=next[po]+po-i;<br/>
            if(j&lt;0)j=0;//如果i&gt;po+next[po],则要从头开始匹配<br/>
            while(i+j&lt;len&amp;&amp;str[j]==str[j+i])//计算next[i]<br/>
            j++;<br/>
            next[i]=j;<br/>
            po=i;//更新po的位置<br/>
        }<br/>
    }<br/>
}<br/>
//计算extend数组<br/>
void EXKMP(char *s1,char *s2)<br/>
{<br/>
    int i=0,j,po,len=strlen(s1),l2=strlen(s2);<br/>
    GETNEXT(s2);//计算子串的next数组<br/>
    while(s1[i]==s2[i]&amp;&amp;i&lt;l2&amp;&amp;i&lt;len)//计算ex[0]<br/>
    i++;<br/>
    ex[0]=i;<br/>
    po=0;//初始化po的位置<br/>
    for(i=1;i&lt;len;i++)<br/>
    {<br/>
        if(next[i-po]+i&lt;ex[po]+po)//第一种情况，直接可以得到ex[i]的值<br/>
        ex[i]=next[i-po];<br/>
        else//第二种情况，要继续匹配才能得到ex[i]的值<br/>
        {<br/>
            j=ex[po]+po-i;<br/>
            if(j&lt;0)j=0;//如果i&gt;ex[po]+po则要从头开始匹配<br/>
            while(i+j&lt;len&amp;&amp;j&lt;l2&amp;&amp;s1[j+i]==s2[j])//计算ex[i]<br/>
            j++;<br/>
            ex[i]=j;<br/>
            po=i;//更新po的位置<br/>
        }<br/>
    }<br/>
}<br/>
字典树<br/>
#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
const int maxn = 1e6 + 7;  <br/>
int id, ch[maxn][30], cnt[maxn];  <br/>
char str[15];  <br/>
void Insert(char *s)  <br/>
{  <br/>
    int rt = 0;  <br/>
    int len = strlen(s);  <br/>
    for(int i = 0; i &lt; len; i++)  <br/>
    {  <br/>
        if(!ch[rt][s[i]-'a'])  <br/>
        {  <br/>
            memset(ch[id], 0, sizeof(ch[id]));  <br/>
            cnt[id] = 0;  <br/>
            ch[rt][s[i]-'a'] = id++;  <br/>
        }  <br/>
        rt = ch[rt][s[i]-'a'];  <br/>
        cnt[rt]++;  <br/>
    }  <br/>
}  <br/>
int match(char *s)  <br/>
{  <br/>
    int rt = 0;  <br/>
    int len = strlen(s);  <br/>
    for(int i = 0; i &lt; len; i++)  <br/>
    {  <br/>
        if(!ch[rt][s[i]-'a'])  <br/>
            return 0;  <br/>
        rt = ch[rt][s[i]-'a'];  <br/>
    }  <br/>
    return cnt[rt];  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    id = 1;  <br/>
    memset(ch[0], 0, sizeof(ch[0]));  <br/>
    while(gets(str))  <br/>
    {  <br/>
        if(!strlen(str)) break;  <br/>
        Insert(str);  <br/>
    }  <br/>
    while(gets(str) != NULL)  <br/>
        printf("%d\n", match(str));  <br/>
    return 0;  <br/>
}  <br/>
矩阵快速幂<br/>
模板

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int MOD = 1e4;  <br/>
struct node  <br/>
{  <br/>
    int matrix[2][2];  <br/>
    node() {}  <br/>
    node(int a, int b, int c, int d)  <br/>
    {  <br/>
        matrix[0][0] = a;  <br/>
        matrix[0][1] = b;  <br/>
        matrix[1][0] = c;  <br/>
        matrix[1][1] = d;  <br/>
    }  <br/>
};  <br/>
node mul(node p, node q)  <br/>
{  <br/>
    node t = node(0, 0, 0, 0);  <br/>
    for(int i = 0; i &lt; 2; i++)  <br/>
        for(int j = 0; j &lt; 2; j++)  <br/>
            for(int k = 0; k &lt; 2; k++)  <br/>
            t.matrix[i][j] = (t.matrix[i][j] + p.matrix[i][k] * q.matrix[k][j]) % MOD;  <br/>
    return t;  <br/>
}  <br/>
node quick_matrix(node p, int n)  <br/>
{  <br/>
    node q = node(1, 0, 0, 1);  <br/>
    while(n)  <br/>
    {  <br/>
        if(n &amp; 1) q = mul(p,q);  <br/>
        p = mul(p, p);  <br/>
        n &gt;&gt;= 1;  <br/>
    }  <br/>
    return q;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int n;  <br/>
    node p;  <br/>
    while(scanf("%d", &amp;n), n+1)  <br/>
    {  <br/>
        p = node(1, 1, 1, 0);  <br/>
        if(n == 0) {printf("0\n" ); continue;}  <br/>
        p = quick_matrix(p, n-1);  <br/>
        printf("%d\n", p.matrix[0][0]);  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
 

错排公式<br/>
 

 

编号为 1 ， 2 ，……， n 的 n 个元素排成一列，若每个元素所处位置的序号都与它的编号不同，则称这个排列为 n 个不同元素的一个错排。记 n 个不同元素的错排总数为 f(n) ，则f(n) = n![1-1/1!+1/2!-1/3!+……+(-1)^n*1/n!]（ 1 ）本文从另一角度对这个问题进行一点讨论。1. 一个简单的递推公式n 个不同元素的一个错排可由下述两个步骤完成：

第一步，“错排” 1 号元素（将 1 号元素排在第 2 至第 n 个位置之一），有 n - 1 <br/>
种方法。<br/>
第二步，“错排”其余 n - 1 个元素，按如下顺序进行。视第一步的结果，若 1 <br/>
号元素落在第 k 个位置，第二步就先把 k 号元素“错排”好， k <br/>
号元素的不同排法将导致两类不同的情况发生：（ 1 ） k 号元素排在第 1 <br/>
个位置，留下的 n - 2 个元素在与它们的编号集相等的位置集上“错排”，有 f(n -2) <br/>
种方法；（ 2 ） k 号元素不排第 1 个位置，这时可将第 1 个位置“看成”第 k <br/>
个位置，于是形成（包括 k 号元素在内的） n - 1 个元素的“错排”，有 f(n - 1) <br/>
种方法。据加法原理，完成第二步共有 f(n - 2)+f(n - 1) 种方法。<br/>
根据乘法原理， n 个不同元素的错排种数f(n) = (n-1)[f(n-2)+f(n-1)] (n&gt;2) 。

#include &lt;iostream&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;cstring&gt;  <br/>
using namespace std;  <br/>
const int maxn = 105;  <br/>
const int mm = 1e9 + 7;  <br/>
long long a[maxn];  <br/>
int main()  <br/>
{  <br/>
    int t,n;  <br/>
    scanf("%d",&amp;t);  <br/>
    a[1] = 0; a[2] = 1;  <br/>
    for(int i = 3; i &lt;= maxn; i++)  <br/>
        a[i] = (i-1)*(a[i-1]+a[i-2])%mm;  <br/>
    while(t--)  <br/>
    {  <br/>
        scanf("%d",&amp;n);  <br/>
        cout &lt;&lt; a[n] &lt;&lt; endl;  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
康拓展开式<br/>
原理

#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
using namespace std;  <br/>
int fact(int x)  <br/>
{  <br/>
    int ans = 1;  <br/>
    for(int i = 1; i &lt; x; i++)  <br/>
        ans *= i;  <br/>
    return ans;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    char str[12];  <br/>
    while(~scanf("%s",str))  <br/>
    {  <br/>
  <br/>
        int len = strlen(str);  <br/>
        int ans = 0;  <br/>
        for(int i = 0; i &lt; len; i++)  <br/>
        {  <br/>
            int l = 0;  <br/>
            for(int j = i + 1; j &lt; len; j++)  <br/>
                if(str[j] &lt; str[i])  <br/>
                l++;  <br/>
            ans += l * fact(len-i);  <br/>
        }  <br/>
        printf("%d\n",ans+1); //康托展开式只是求他前面有几个值，求这个数式第几个值还得+1；  <br/>
    }  <br/>
    return  0;  <br/>
}  <br/>
逆康拓展开

int  fac[] = {1,1,2,6,24,120,720,5040,40320};    <br/>
//康托展开的逆运算,{1...n}的全排列，中的第k个数为s[]    <br/>
void reverse_kangtuo(int n,int k,char s[])    <br/>
{    <br/>
    int i, j, t, vst[8]={0};    <br/>
    --k;    <br/>
    for (i=0; i&lt;n; i++)    <br/>
    {    <br/>
        t = k/fac[n-i-1];    <br/>
        for (j=1; j&lt;=n; j++)    <br/>
            if (!vst[j])    <br/>
            {    <br/>
                if (t == 0) break;    <br/>
                --t;    <br/>
            }    <br/>
        s[i] = '0'+j;    //注意这里是s【i】，用i保存  <br/>
        vst[j] = 1;    <br/>
        k %= fac[n-i-1];    <br/>
    }    <br/>
}<br/>
HDU 1027<br/>
#include&lt;iostream&gt;  <br/>
#include&lt;cstdio&gt;  <br/>
#include&lt;cstring&gt;  <br/>
#include&lt;cmath&gt;  <br/>
using namespace std;  <br/>
const int maxn = 10;  <br/>
int fac[maxn] = {1, 1};  <br/>
bool vis[100005];  <br/>
  <br/>
void init()  <br/>
{  <br/>
    for(int i = 2 ; i &lt; maxn; i++)  <br/>
        fac[i] = fac[i-1]*i;  <br/>
}  <br/>
  <br/>
int main(void)  <br/>
{  <br/>
    init();  <br/>
    int n, m;  <br/>
    while(cin &gt;&gt; n &gt;&gt; m)  <br/>
    {  <br/>
        memset(vis, 0, sizeof(vis));  <br/>
        m--;  <br/>
        int temp = 1;  <br/>
        while(temp &lt; n)  <br/>
        {  <br/>
            if((n-temp) &lt;= 8)  <br/>
            {  <br/>
                int k = m/fac[n-temp];  <br/>
                m = m%fac[n-temp];  <br/>
                int cnt = 0;  <br/>
                for(int i = 1; i &lt;= n; i++)  <br/>
                {  <br/>
                    if(!vis[i]) cnt++;  <br/>
                    if((cnt-1) == k)  <br/>
                    {  <br/>
                        printf("%d ", i);  <br/>
                        vis[i] = 1; break;  <br/>
                    }  <br/>
                }  <br/>
            }  <br/>
            else  <br/>
            {  <br/>
                for(int i = 1; i &lt;= n; i++)  <br/>
                {  <br/>
                    if(!vis[i])  <br/>
                    {  <br/>
                        vis[i] = 1;  <br/>
                        printf("%d ", i); break;  <br/>
                    }  <br/>
                }  <br/>
            }  <br/>
            ++temp;  <br/>
        }  <br/>
        for(int i=1; i&lt;=n; i++)  <br/>
            if(!vis[i]) printf("%d\n", i);  <br/>
    }  <br/>
    return 0;  <br/>
}      <br/>
逆元<br/>
原理

罗马小定理

#include&lt;bits/stdc++.h&gt;  <br/>
using namespace std;  <br/>
const int mod = 9973;  <br/>
const int maxn = 1e5+5;  <br/>
char str[maxn];  <br/>
int h[maxn];  <br/>
  <br/>
int p(int a, int n)  <br/>
{  <br/>
    int ans = 1;  <br/>
    while(n)  <br/>
    {  <br/>
        if(n&amp;1) ans = ans*a%mod;  <br/>
        a = a*a%mod;  <br/>
        n /= 2;  <br/>
    }  <br/>
    return ans;  <br/>
}  <br/>
  <br/>
int main(void)  <br/>
{  <br/>
    int q, a, b;  <br/>
    h[0] = 1;  <br/>
    while(cin &gt;&gt; q)  <br/>
    {  <br/>
        scanf(" %s", str);  <br/>
        int len = strlen(str);  <br/>
        for(int i = 0; i &lt; len; i++)  <br/>
            h[i+1] = h[i]*(str[i]-28)%mod;  <br/>
        while(q--)  <br/>
        {  <br/>
            scanf("%d%d", &amp;a, &amp;b);  <br/>
            printf("%d\n", h[b]*p(h[a-1], mod-2)%mod);  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
线性逆元

#include&lt;bits/stdc++.h&gt;  <br/>
using namespace std;  <br/>
const int mod = 9973;  <br/>
const int maxn = 1e5+5;  <br/>
char str[maxn];  <br/>
int q, a, b, inv[maxn], h[maxn];  <br/>
int main(void)  <br/>
{  <br/>
    h[0] = inv[1] = 1;  <br/>
    for(int i = 2; i &lt; mod; i++)  <br/>
        inv[i] = (mod-mod/i)*inv[mod%i]%mod;  <br/>
    while(cin &gt;&gt; q)  <br/>
    {  <br/>
        scanf(" %s", str);  <br/>
        int len = strlen(str);  <br/>
        for(int i = 0; i &lt; len; i++)  <br/>
            h[i+1] = h[i]*(str[i]-28)%mod;  <br/>
        while(q--)  <br/>
        {  <br/>
            scanf("%d%d", &amp;a, &amp;b);  <br/>
            printf("%d\n", h[b]*inv[h[a-1]]%mod);  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
线性筛<br/>
#include&lt;bits/stdc++.h&gt;<br/>
using namespace std;<br/>
int n,cnt;<br/>
int prime[100000];<br/>
bool vis[100000];<br/>
 <br/>
void Euler()<br/>
{<br/>
    for(int i=2;i&lt;=n;i++)<br/>
    {<br/>
        if(!vis[i]) prime[++cnt]=i;<br/>
        for(int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)<br/>
        {<br/>
            vis[i*prime[j]]=1;<br/>
            if(i%prime[j]==0)<br/>
            break;<br/>
        }<br/>
    }<br/>
}<br/>
 <br/>
int main()<br/>
{<br/>
  cin&gt;&gt;n;<br/>
  Euler();<br/>
  for(int i=1;i&lt;=cnt;i++)<br/>
  cout&lt;&lt;prime[i]&lt;&lt;' ';<br/>
  return 0;<br/>
}<br/>
LCA<br/>
原理挑战程序设计

#include &lt;iostream&gt;  <br/>
#include &lt;cstring&gt;  <br/>
#include &lt;cstdio&gt;  <br/>
#include &lt;algorithm&gt;  <br/>
using namespace std;  <br/>
const int maxn = 1e4 + 7;  <br/>
const int maxm = 21;  <br/>
int n, dis[maxn], dep[maxn], p[maxm][maxn], head[maxn], K;  <br/>
struct node  <br/>
{  <br/>
    int v, w, next;  <br/>
    node(){}  <br/>
}edge[maxn*2];  <br/>
void init()  <br/>
{  <br/>
    memset(head, -1, sizeof(head));  <br/>
    K = 0;  <br/>
}  <br/>
void addEdge(int u, int v, int w)  <br/>
{  <br/>
    edge[K].v = v;  <br/>
    edge[K].w = w;  <br/>
    edge[K].next = head[u];  <br/>
    head[u] = K++;  <br/>
}  <br/>
void dfs(int u, int f, int d)  <br/>
{  <br/>
    dep[u] = d;  <br/>
    p[0][u] = f;  <br/>
    for(int i = head[u]; i != -1; i = edge[i].next)  <br/>
    {  <br/>
        int to = edge[i].v;  <br/>
        if(to == f) continue;  <br/>
        dis[to] = dis[u] + edge[i].w;  <br/>
        dfs(to, u, d+1);  <br/>
    }  <br/>
}  <br/>
void build()  //构建lca  <br/>
{  <br/>
    dfs(1, -1, 0);  //第一遍统计， 1是根节点  <br/>
    for(int i = 0; i+1 &lt; maxm; i++)  <br/>
    {  <br/>
        for(int v = 1; v &lt;= n; v++)  <br/>
        {  <br/>
            if(p[i][v] &lt; 0) p[i+1][v] = -1;  <br/>
            else p[i+1][v] = p[i][p[i][v]];  <br/>
        }  <br/>
    }  <br/>
}  <br/>
int LCA(int u, int v)  <br/>
{  <br/>
    if(dep[u] &gt; dep[v]) swap(u, v);  <br/>
    for(int i = 0; i &lt; maxm; i++)  <br/>
    {  <br/>
        if((dep[v]-dep[u])&gt;&gt;i&amp;1)  <br/>
            v = p[i][v];  <br/>
    }  <br/>
    if(u == v) return u;  <br/>
    for(int i = maxm-1; i &gt;= 0; i--)  <br/>
    {  <br/>
        if(p[i][u] != p[i][v])  <br/>
        {  <br/>
            u = p[i][u];  <br/>
            v = p[i][v];  <br/>
        }  <br/>
    }  <br/>
    return p[0][u];  <br/>
}  <br/>
int get_kth(int u, int v, int lca, int k) //寻找这条路径上第k个点  <br/>
{  <br/>
    k--;  //因为u算第一个点， 所以k--  <br/>
    if(dep[u] - dep[lca] &lt; k)  //如果第k个节点要跨过lca那个点，就等于求v到他那条链上距离为k'的点  <br/>
    {  <br/>
        k = dep[u] + dep[v] - dep[lca]*2 - k; //k'  <br/>
        u = v;  <br/>
    }  <br/>
    for(int i = 0; i &lt; maxm; i++)  //倍增找距离这个节点为k的节点，注意这里是从0开始循环的，求距离内最远的某个点就要倒着了  <br/>
        if(k &amp; (1&lt;&lt;i))  <br/>
            u = p[i][u], k ^= (1&lt;&lt;i);  <br/>
    return u;  <br/>
}  <br/>
int main()  <br/>
{  <br/>
    int T;  <br/>
    scanf("%d", &amp;T);  <br/>
    while(T--)  <br/>
    {  <br/>
        scanf("%d", &amp;n);  <br/>
        init();  <br/>
        int u, v, w;  <br/>
        for(int i = 1; i &lt; n; i++)  <br/>
        {  <br/>
            scanf("%d%d%d", &amp;u, &amp;v, &amp;w);  <br/>
            addEdge(u, v, w);  <br/>
            addEdge(v, u, w);  <br/>
        }  <br/>
        build();  <br/>
        char cmd[10];  <br/>
        while(1)  <br/>
        {  <br/>
            scanf("%s", cmd);  <br/>
            if(cmd[1] == 'O') break;  <br/>
            scanf("%d%d", &amp;u, &amp;v);  <br/>
            if(cmd[1] == 'I')  <br/>
            {  <br/>
                int lca = LCA(u, v);  <br/>
                printf("%d\n", dis[u] + dis[v] - 2*dis[lca]); //常规的求两点路径的距离  <br/>
            }  <br/>
            else  <br/>
            {  <br/>
                int k;  <br/>
                scanf("%d", &amp;k);  <br/>
                int lca = LCA(u, v);  <br/>
                printf("%d\n", get_kth(u, v, lca, k));  <br/>
            }  <br/>
        }  <br/>
    }  <br/>
    return 0;  <br/>
}  <br/>
 

 <br/>
 
